---
modules:
  - docassemble.VirtualCourtToolbox.shortenURL
---
include:
  - remote_sign_on_device.yml
  - remote_signer_entrypoint.yml
  - docassemble.MAVirtualCourt:basic-questions.yml
---
objects:
  - redis: DARedis
  - all_signers: DAList.using(object_type=Individual, auto_gather=False)
  - others: DAList.using(object_type=Individual, auto_gather=False)
  - action_data: DADict.using(there_is_another=False, gathered= True)
  - signatures: DADict.using(there_is_another=False, gathered= True)
  - signers_by_id: DADict.using(there_is_another=False, gathered= True)
---
mandatory: True
code: |
  # Save data to redis
  # action_key (unique to this legal action), user_id, party_id
  # Send link generated by something. The remote interview entrypoint?
  # Start the remote entrypoint. Has a mandatory block.
  # Remote entrypoint uses remote_sign_on_device.yml to get signature. Can customize questions and data.
  # redist.set_data( 'action_key', { parties: {}, preview: doc, }, expire=3)
  # url_args needed: action_key, party_id, user_id

  users[0].name.first
  users[0].has_signed = False
  users.gathered = True
  users.there_is_another = False

  others[0].name.first
  others[0].has_signed = False
  others[1].name.first
  others[1].has_signed = False
  others.gathered = True
  others.there_is_another = False

  all_signers = users + others
  all_signers.gathered = True
  all_signers.there_is_another = False

  for signer in all_signers:
    signers_by_id[ signer.id ] = signer
  # Needed these to be defined at one point...
  signers_by_id.there_is_another = False
  signers_by_id.gathered = True

  ## TODO: Discuss - This sort of looks like there's only one user per interview, so maybe we don't need a list of users.

  # https://docassemble.org/docs/objects.html#DAFile.set_attributes
  # Do we want persistance so that signers can see their document even after the user has exited the interview?
  signature_doc.set_attributes(persistent=True, private=False)

  ## If authorization is implemented in interview, this must come after users[0] is defined. Very fragile.
  action_key # var name? legal_action? with same people. one form...

  set_initial_redis_data
  
  log( others[0].signature_url, 'console' )
  log( others[1].signature_url, 'console' )
  
  users[0].willing_to_sign = True
  users[0].sign_on_device
---
code: |
  action_key = get_random_chars()
---
code: |
  action_data[ 'user_id' ] = users[0].id
  #log( 'user id: ' + users[0].id, 'console' )

  action_data[ 'parties' ] = signers_by_id
  #log( signers_by_id, 'console' )

  #action_data[ 'preview' ] = signature_doc
  action_data[ 'signed_doc' ] = signature_doc
  action_data.there_is_another = False
  action_data.gathered = True
  
  redis.set_data( action_key, action_data, expire=(1* 6 * 60 * 60 * 1000) )
  set_initial_redis_data = True
---
code: |
  # So others can see it on their own
  users[0].signature.set_attributes(persistent=True, private=False)
  action_data[ 'parties' ][ users[0].id ].signature = users[0].signature
  action_data[ 'parties' ][ users[0].id ].signature_date = today()
  action_data[ 'parties' ][ users[0].id ].has_signed = True
  redis.set_data( action_key, action_data )
  set_redis_user_signature = True
---
event: x.after_signature
generic object: Individual
code: |
  set_redis_user_signature
  others[0].was_notified
  users[0].status
---
code: |
  others[0].signature = ''
  others[1].signature = ''
  set_initial_signatures = True
---
generic object: Individual
code: |
  #message_success = send_sms(task='send cosigner signature link', to=x.mobile_number, template=x.sms_template)
  
  #message_success = send_email(to=x, template=x.email_template)
  x.was_notified = True
---
id: get info for sending link
generic object: Individual
question: |
  How do you want to send the link to ${ x }
fields:
  - Phone number to text: x.mobile_number
    required: False
  - Email: x.email
    required: False
continue button field: x.send_method
---
id: sms template multiuser
generic object: Individual
template: x.sms_template
content: |
  Dear ${ x },
  You decided to sign the document on this device. Go to ${ x.signature_url } to sign your document
---
id: email template multiuser
generic object: Individual
template: x.email_template
subject: Remote signature test
content: |
  Dear ${ x },
  You decided to sign the document on this device. Go to ${ x.signature_url } to sign your document
---
generic object: Individual
question: |
  Name
fields:
  - First: x.name.first
---
generic object: Individual
code: |
  x.signature_url = shortenMe( x.signature_url_string ).shortenedURL
---
id: x.signature
generic object: Individual
question: |
  ${x}'s signature
signature: x.signature
---
id: document
event: x.status
reconsider:
  - get_current_signatures
  - signature_doc
generic object: Individual
prevent going back: True
question: |
  Test document signatures for ${ users[0] }
subquestion: |
  ${ signature_doc }
---
attachment:
  name: Signatures doc
  variable name: signature_doc
  filename: signatures
  docx template file: test-signatures.docx
  #persistent: True
  #private: False
---
event: get_current_signatures
code: |
  new_data = redis.get_data( action_key )
  signing_parties = new_data[ 'parties' ]
  for signer in all_signers:
    if signer.id in signing_parties:
      log( 'has signed: ', 'console' )
      log( signer.id, 'console' )
      log( signing_parties[ signer.id ].has_signed, 'console' )
      if signing_parties[ signer.id ].has_signed:
        signer.signature = signing_parties[ signer.id ].signature
  
---
generic object: Individual
code: |
  x.id = get_random_chars()
---
code: |
  import random
  import string
  def get_random_chars(num_chars=10):
    return ''.join(random.choice(string.ascii_lowercase) for i in range(10))
---