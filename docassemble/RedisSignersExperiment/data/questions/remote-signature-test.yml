comment: |
  Some pre-made functionality for mutli-user signatures.

  `remote` in here refers to devices of signers other than the user or those using the user's device.
  
  As usual, these can all be customized. It just hopes these help save brain cells.
---
# Make own function to make this more independent?
modules:
  - docassemble.VirtualCourtToolbox.misc
---
include:
  - signature_originator_store_handler.yml
---
mandatory: True
code: |
  multi_user = True
---
#code: |
#  interview_data_id
#
#  # DEVELOPER: Assumes list of users
#  if not defined('all_signers'):
#    all_signers = users
#
#  # Have to abstract so devs can create/use their own docs and text effectively?
#  # DEVELOPERS: Create `interview_data` elsewhere, as shown below
#  interview_data = {}
#  if defined('custom_signature_redis_data'):
#    interview_data = custom_signature_redis_data
#  
#  parties = {}
#  for signer in all_signers:
#    parties[ signer.id ] = {
#      "has_signed": False, "willing_to_sign": None, "name": str( signer )
#    }
#  interview_data[ 'parties' ] = parties
#  
#  redis.set_data( interview_data_id, interview_data, expire=remote_siganure_expiration_ms )
#  set_initial_redis_data = True
---
## Updates user doc with remote signatures
#code: |
#  new_data = redis.get_data( interview_data_id )
#  signing_parties = new_data[ 'parties' ]
#  for signer in all_signers:
#    if signer.id in signing_parties:
#      # TODO: Test this thoroughly
#      if signing_parties[ signer.id ][ 'has_signed' ]:
#        signer.has_signed = signing_parties[ signer.id ][ 'has_signed' ]
#        signer.signature = signing_parties[ signer.id ][ 'signature' ]
#
#  get_stored_signatures = True
---
## Makes sure `has_signed` is always at least defined
#generic object: Individual
#code: |
#  x.has_signed = False
---
#code: |
#  for remote_signer in remote_signers:
#    remote_signer.signature_url_was_sent  # Send message
#  request_remote_signatures = True
---
#generic object: Individual
#code: |
#  if x.send_method == 'text': 
#    x.message_result = send_sms(task='send sms_template', to=x.mobile_number, template=x.sms_template)
#  else:
#    x.message_result = send_email(to=x, template=x.email_template)
#  x.signature_url_was_sent = True
---
#generic object: Individual
#code: |
#  url_str = interview_url(
#    interview_data_id = interview_data_id,
#    party_id = x.id,
#    new_session = '1',
#    i=remote_signer_url_end  # The url the co-signer will go to
#  )
#
#  x.cosigner_url = shortenMe( url_str ).shortenedURL
---
#code: |
#  interview_data_id = get_random_chars()
#---
#generic object: Individual
#code: |
#  x.id = get_random_chars()
#---
#code: |
#  import random
#  import string
#  def get_random_chars(num_chars=10):
#    return ''.join(random.choice(string.ascii_lowercase) for i in range(10))
---
###################
# For interfacing with code to send to co-signers
##################
---
code: |
  # When the saved redis data will expire
  remote_siganure_expiration_ms = 1* 8 * 60 * 60 * 1000  # 6hrs
---
# Keep in as the default
code: |
  # DEVELOPERS: Use the name of your own remote entrypoint file
  remote_signer_url_end = user_info().package + ':remote_signer_entrypoint.yml'
---
code: |
  # Whatever info you want to be able to use for the co-signers' interview
  custom_signature_redis_data = { 'user_names': str(users), 'signed_doc': signature_doc, }  #'no doc given' } # signature_doc, } #'preview': signature_doc }
---
######################
# Questions for multi-user signatures
######################
---
# co-signer `.email` and `.mobile_number` are required
# `.mobile_number` might better be called `.remote_number` and may change it
id: how to send to remote signer
generic object: Individual
question: |
  Do you want to send this to ${ x } by email or text?
fields:
  - no label: x.send_method
    datatype: radio
    choices:
      - Email: email
      - Text: text
  - What is their email?: x.signature_email
    js show if: |
      val("x.send_method") == "email"
  - What is their phone number?: x.signature_number
    js show if: |
      val("x.send_method") == "text"
---
id: sms template multiuser
generic object: Individual
template: x.sms_template
content: |
  Dear ${ x },
  ${ users[0] } is asking you to sign a document. Go to ${ x.cosigner_url } to sign the document.
---
id: email template multiuser
generic object: Individual
template: x.email_template
subject: Remote signature test
content: |
  Dear ${ x },
  ${ users[0] } is asking you to sign a document. Go to ${ x.cosigner_url } to sign the document.
---
######################
# Interfacing with code to let user choose which device to sign on
######################
---
generic object: Individual
code: |
  # TODO: Should this be in sign_on_device.yml?
  # TODO: Send with action arguments (in templates)
  #if x.send_method == 'text':
  #  x.send_sms_signature_link
  #elif x.send_method == 'email':  # Not implemented for MVP
  #  x.send_email_signature_link
  x.message_result = send_sms(task='send link to other device', to=x.device_number, template=x.sms_device_template)
  x.send_signature_link = True  # Used by sign_on_device.yml
---
generic object: Individual
code: |
  # `action` experiments for true device choice begin here
  long_device_choice_url = interview_url_action( 'signature_with_device_choice', device_id='tbd', signature_data_id=signature_data_id, party_id=x.id )
  device_choice_url = shortenMe( long_device_choice_url ).shortenedURL
---
# Triggered by new device
event: signature_with_device_choice
code: |
  users[0].sign_on_device
---
######################
# Questions for choosing device to sign on
######################
---
id: number to text
generic object: Individual
question: |
  What number do you want to text?
fields:
  - no label: x.device_number
    default: ${ showifdef( x.instanceName + '.mobile_number' )}
---
generic object: Individual
template: x.sms_device_template
content:
  You have chosen to sign on this device, ${ x }. Sign your document at the link below

  ${ device_choice_url }
---
id: x.signature
generic object: Individual
question: |
  ${x}'s signature
signature: x.signature
---
######################
# For interfacing with code of both
######################
---
# After the user signs, the links for the co-signers get sent
event: x.after_signature
generic object: Individual
code: |
  if device() and device().is_pc:
    request_remote_signatures
    after_remote_signatures_requested
  else:
    if wants_to_finish_on_phone:
      request_remote_signatures
      after_remote_signatures_requested
    else:
      phone_end
---
event: after_remote_signatures_requested
code: |
  # Request other signatures under here
  # Possibly using action arguments when that's worked out
  users[0].status
---
######################
# The sparks that set off the fires
######################
---
objects:
  - users: DAList.using(object_type=Individual, auto_gather=False)
  - others: DAList.using(object_type=Individual, auto_gather=False)
---
mandatory: True
code: |
  # Save data to redis
  # interview_data_id (unique to this legal action), user_name, party_id
  # Send link generated by something. The remote interview entrypoint?
  # Start the remote entrypoint. Has a mandatory block.
  # Remote entrypoint uses remote_sign_on_device.yml to get signature. Can customize questions and data.
  # redist.set_data( 'interview_data_id', { parties: {}, preview: doc, }, expire=3)
  # url_args needed: interview_data_id, party_id, user_id

  users[0].name.first
  users.gathered = True
  local_signers = users

  others[0].name.first
  others[1].name.first
  others.gathered = True
  others.there_is_another = False
  remote_signers = [ others[0], others[1] ]

  all_signers = users + others
  all_signers.gathered = True
  all_signers.there_is_another = False

  ## TODO: Discuss - This sort of looks like there's only one user per interview, so maybe we don't need a list of users.

  # https://docassemble.org/docs/objects.html#DAFile.set_attributes
  # Do we want persistance so that signers can see their document even after the user has exited the interview?
  # Developer: Do this before setting redis data
  signature_doc.set_attributes(persistent=True, private=False)
  custom_signature_redis_data
  set_initial_redis_data
  
  users[0].sign_on_device
---
generic object: Individual
question: |
  ${ x.instanceName }  name
fields:
  - First: x.name.first
---
id: ask wants to finish on phone
question: |
  Do you want to finish on your phone?
yesno: wants_to_finish_on_phone
---
event: phone_end
question: |
  Thank you
subquestion: |
  You can finish on your original device.
---
id: document
event: x.status
# Problem - developer _needs_ to reconsider `get_stored_signatures`
# Not sure this can be abstracted away
# DEVELOPER: Must reconsider these two things
reconsider:
  - get_stored_signatures
  - signature_doc
generic object: Individual
#prevent going back: True
question: |
  Test document signatures for ${ users[0] }
subquestion: |
  ${ signature_doc }
  
  ${ action_button_html('javascript:daShowSpinner();daRefreshSubmit()', label='Check again <i class="fas fa-sync-alt"></i>', size='lg') }
---
attachment:
  name: Signatures doc
  variable name: signature_doc
  filename: signatures
  docx template file: test-signatures.docx
  #persistent: True
  #private: False
